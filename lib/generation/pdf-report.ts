/**
 * Findings PDF Report Generator
 *
 * Generates a professional PDF report of all pipeline findings for a matter.
 * Reuses pdf-lib patterns from the demo PDF generator.
 */

import { PDFDocument, StandardFonts, rgb, PDFPage, PDFFont } from "pdf-lib";
import type { GenerationContext, FindingEntry } from "./context-builder";

// Colors
const HEADER_COLOR = rgb(0.1, 0.1, 0.4);
const TEXT_COLOR = rgb(0, 0, 0);
const MUTED_COLOR = rgb(0.4, 0.4, 0.4);
const LIGHT_BG = rgb(0.95, 0.95, 0.97);
const DIVIDER_COLOR = rgb(0.7, 0.7, 0.7);

// Impact badge colors
const IMPACT_COLORS: Record<string, ReturnType<typeof rgb>> = {
  critical: rgb(0.8, 0.1, 0.1),
  high: rgb(0.85, 0.4, 0.1),
  medium: rgb(0.7, 0.6, 0.0),
  low: rgb(0.2, 0.6, 0.2),
  info: rgb(0.3, 0.3, 0.6),
};

// Status labels
const STATUS_LABELS: Record<string, string> = {
  pending: "Pending",
  accepted: "Accepted",
  rejected: "Rejected",
  auto_applied: "Auto-applied",
  conflict: "Conflict",
};

function addWrappedText(
  page: PDFPage,
  text: string,
  x: number,
  y: number,
  maxWidth: number,
  font: PDFFont,
  size: number,
  lineHeight: number,
  color = TEXT_COLOR
): number {
  const words = text.split(" ");
  let line = "";
  let currentY = y;

  for (const word of words) {
    const testLine = line + (line ? " " : "") + word;
    const testWidth = font.widthOfTextAtSize(testLine, size);

    if (testWidth > maxWidth && line) {
      page.drawText(line, { x, y: currentY, size, font, color });
      currentY -= lineHeight;
      line = word;
    } else {
      line = testLine;
    }
  }

  if (line) {
    page.drawText(line, { x, y: currentY, size, font, color });
    currentY -= lineHeight;
  }

  return currentY;
}

function addLetterhead(page: PDFPage, firmName: string, font: PDFFont, boldFont: PDFFont): number {
  const { width } = page.getSize();
  let y = page.getSize().height - 50;

  page.drawText(firmName, { x: 50, y, size: 16, font: boldFont, color: HEADER_COLOR });
  y -= 25;

  page.drawText("Case Findings Report", { x: 50, y, size: 12, font, color: MUTED_COLOR });
  y -= 20;

  page.drawLine({
    start: { x: 50, y },
    end: { x: width - 50, y },
    thickness: 1,
    color: DIVIDER_COLOR,
  });
  return y - 20;
}

function addFooter(
  page: PDFPage,
  font: PDFFont,
  pageNum: number,
  totalPages: number,
  date: string
): void {
  const { width } = page.getSize();
  page.drawText(`Generated by Legal Copilot — ${date} — Page ${pageNum} of ${totalPages}`, {
    x: 50,
    y: 30,
    size: 7,
    font,
    color: MUTED_COLOR,
  });
  page.drawText("Confidential", {
    x: width - 100,
    y: 30,
    size: 7,
    font,
    color: MUTED_COLOR,
  });
}

export interface FindingsReportParams {
  context: GenerationContext;
}

export async function generateFindingsReport(params: FindingsReportParams): Promise<Uint8Array> {
  const { context } = params;
  const doc = await PDFDocument.create();
  const font = await doc.embedFont(StandardFonts.Helvetica);
  const boldFont = await doc.embedFont(StandardFonts.HelveticaBold);
  const italicFont = await doc.embedFont(StandardFonts.HelveticaOblique);

  const pages: PDFPage[] = [];
  let currentPage = doc.addPage([595, 842]); // A4
  pages.push(currentPage);

  let y = addLetterhead(currentPage, context.firm.name, font, boldFont);

  // Meta info
  currentPage.drawText(`Matter: ${context.matter.reference} — ${context.matter.title}`, {
    x: 50,
    y,
    size: 10,
    font: boldFont,
    color: TEXT_COLOR,
  });
  y -= 16;
  currentPage.drawText(`Client: ${context.client.name}`, {
    x: 50,
    y,
    size: 9,
    font,
    color: TEXT_COLOR,
  });
  y -= 14;
  currentPage.drawText(`Date: ${context.today}`, {
    x: 50,
    y,
    size: 9,
    font,
    color: MUTED_COLOR,
  });
  y -= 14;

  const total = Object.values(context.statusCounts).reduce((a, b) => a + b, 0);
  const statusLine = `Findings: ${total} total — ${context.statusCounts.pending} pending, ${context.statusCounts.accepted} accepted, ${context.statusCounts.rejected} rejected, ${context.statusCounts.auto_applied} auto-applied, ${context.statusCounts.conflict} conflicts`;
  currentPage.drawText(statusLine, { x: 50, y, size: 8, font, color: MUTED_COLOR });
  y -= 25;

  // Helper: ensure enough space, add new page if needed
  function ensureSpace(needed: number): void {
    if (y < needed) {
      currentPage = doc.addPage([595, 842]);
      pages.push(currentPage);
      y = 800;
    }
  }

  const categoryKeys = Object.keys(context.findingsByCategory);

  if (categoryKeys.length === 0) {
    ensureSpace(100);
    currentPage.drawText("No findings have been extracted for this matter.", {
      x: 50,
      y,
      size: 11,
      font,
      color: MUTED_COLOR,
    });
    y -= 20;
  }

  for (const catKey of categoryKeys) {
    const findings = context.findingsByCategory[catKey];

    // Category header
    ensureSpace(120);
    const catLabel = catKey.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());

    currentPage.drawRectangle({
      x: 45,
      y: y - 5,
      width: 505,
      height: 22,
      color: rgb(0.15, 0.15, 0.4),
    });
    currentPage.drawText(catLabel, {
      x: 55,
      y: y + 2,
      size: 10,
      font: boldFont,
      color: rgb(1, 1, 1),
    });
    currentPage.drawText(`${findings.length} finding${findings.length !== 1 ? "s" : ""}`, {
      x: 460,
      y: y + 2,
      size: 8,
      font,
      color: rgb(0.8, 0.8, 1),
    });
    y -= 30;

    // Table header
    currentPage.drawRectangle({ x: 45, y: y - 4, width: 505, height: 16, color: LIGHT_BG });
    currentPage.drawText("Field", { x: 50, y, size: 7, font: boldFont, color: MUTED_COLOR });
    currentPage.drawText("Value", { x: 180, y, size: 7, font: boldFont, color: MUTED_COLOR });
    currentPage.drawText("Conf.", { x: 380, y, size: 7, font: boldFont, color: MUTED_COLOR });
    currentPage.drawText("Impact", { x: 420, y, size: 7, font: boldFont, color: MUTED_COLOR });
    currentPage.drawText("Status", { x: 480, y, size: 7, font: boldFont, color: MUTED_COLOR });
    y -= 18;

    for (const finding of findings) {
      ensureSpace(100);

      // Label
      const label = finding.label.length > 25 ? finding.label.slice(0, 24) + "…" : finding.label;
      currentPage.drawText(label, { x: 50, y, size: 8, font, color: TEXT_COLOR });

      // Value (truncated)
      const val = finding.value.length > 35 ? finding.value.slice(0, 34) + "…" : finding.value;
      currentPage.drawText(val, { x: 180, y, size: 8, font, color: TEXT_COLOR });

      // Confidence bar
      const confPct = Math.min(finding.confidence / 100, 1);
      const barWidth = 30;
      currentPage.drawRectangle({
        x: 380,
        y: y - 2,
        width: barWidth,
        height: 8,
        color: rgb(0.9, 0.9, 0.9),
      });
      currentPage.drawRectangle({
        x: 380,
        y: y - 2,
        width: barWidth * confPct,
        height: 8,
        color:
          confPct > 0.8
            ? rgb(0.2, 0.6, 0.2)
            : confPct > 0.5
              ? rgb(0.7, 0.6, 0)
              : rgb(0.8, 0.2, 0.2),
      });

      // Impact badge
      const impactColor = IMPACT_COLORS[finding.impact] || MUTED_COLOR;
      currentPage.drawText(finding.impact, {
        x: 420,
        y,
        size: 7,
        font: boldFont,
        color: impactColor,
      });

      // Status
      currentPage.drawText(STATUS_LABELS[finding.status] || finding.status, {
        x: 480,
        y,
        size: 7,
        font,
        color: MUTED_COLOR,
      });
      y -= 14;

      // Source quote (if present)
      if (finding.sourceQuote) {
        ensureSpace(60);
        y = addWrappedText(
          currentPage,
          `"${finding.sourceQuote}"`,
          65,
          y,
          470,
          italicFont,
          7,
          10,
          MUTED_COLOR
        );
        y -= 4;
      }
    }

    y -= 10; // gap between categories
  }

  // Add footers to all pages
  for (let i = 0; i < pages.length; i++) {
    addFooter(pages[i], font, i + 1, pages.length, context.today);
  }

  return doc.save();
}
